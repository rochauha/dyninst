.. _`sec:stackwalk-intro`:

=========
Stackwalk
=========

This document describes StackwalkerAPI, an API and library for walking a
call stack. The call stack (also known as the run-time stack) is a stack
found in a process that contains the currently active stack frames. Each
stack frame is a record of an executing function (or function-like
object such as a signal handler or system call). StackwalkerAPI provides
an API that allows users to collect a call stack (known as walking the
call stack) and access information about its stack frames. The current
implementation supports Linux/x86, Linux/x86-64, Linux/Power,
Linux/Power-64, and Windows/x86.

StackwalkerAPI is designed to be both easy-to-use and easy-to-extend.
Users can easily use StackwalkerAPI to walk a call stack without needing
to understand how call stacks are laid out on their platform. Users can
easily extend StackwalkerAPI to work with new platforms and types of
stack frames by implementing a set of callbacks that can be plugged into
StackwalkerAPI.

StackwalkerAPI’s ease-of-use comes from it providing a platform
independent interface that allows users to access detailed information
about the call stack. For example, the following C++ code-snippet is all
that is needed to walk and print the call stack of the currently running
thread.

.. code-block:: cpp

   std::vector<Frame> stackwalk; 
   string s;

   Walker *walker = Walker::newWalker();
   walker->walkStack(stackwalk);
   for (unsigned i=0; i<stackwalk.size(); i++) {
   		stackwalk[i].getName(s);
   		cout << "Found function " << s << endl;
   }	

StackwalkerAPI can walk a call stack in the same address space as where
the StackwalkerAPI library lives (known as a first party stackwalk), or
it can walk a call stack in another process (known as a third party
stackwalk). To change the above example to perform a third party
stackwalk, we would only need to pass a process identifier to newWalker,
e.g:

.. code-block:: cpp

   Walker *walker = Walker::newWalker(pid);

Our other design goal with StackwalkerAPI is to make it easy-to-extend.
The mechanics of how to walk through a stack frame can vary between
different platforms, and even between different types of stack frames on
the same platform. In addition, different platforms may have different
mechanisms for reading the data in a call stack or looking up symbolic
names that go with a stack frame. StackwalkerAPI provides a callback
interface for plugging in mechanisms for handling new systems and types
of stack frames. The callback interface can be used to port
StackwalkerAPI to new platforms, extend StackwalkerAPI support on
existing systems, or more easily integrate StackwalkerAPI into existing
tools. There are callbacks for the following StackwalkerAPI operations:

Walk through a stack frame
   StackwalkerAPI will find different types of stack frames on different
   platforms and even within the same platform. For example, on
   Linux/x86 the stack frame generated by a typical function looks
   different from the stack frame generated by a signal handler. The
   callback interface can be used to register a handler with
   StackwalkerAPI that knows how to walk through a new type of stack
   frame. For example, the DyninstAPI tool registers an object with
   StackwalkerAPI that describes how to walk through the stack frames
   generated by its instrumentation.

Access process data
   To walk a call stack, StackwalkerAPI needs to be able to read a
   process’ memory and registers. When doing a first party stackwalk,
   this is done by directly reading them from the current address space.
   When doing a third party stackwalk, this is done by reading them
   using a debugger interface. The callback interface can be used to
   register new objects for accessing process data. This can be used,
   for example, to port StackwalkerAPI to a new operating system or make
   it work with a new debugger interface.

Look up symbolic names
   When StackwalkerAPI finds a stack frame, it gets an address that
   points into the piece of code that created that stack frame. This
   address is not necessarily meaningful to a user, so StackwalkerAPI
   attempts to associate the address with a symbolic name. The callback
   interface can be used to register an object with StackwalkerAPI that
   performs an address to name mapping, allowing StackwalkerAPI to
   associate names with stack frames.

.. _`sec:stackwalk-abstractions`:

Abstractions
============

StackwalkerAPI contains two interfaces: the Stackwalking Interface and
the Callback Interface. The stackwalking interface is used to walk the
call stack, query information about stack frames, and collect basic
information about threads. The Callback Interface is used to provide
custom mechanisms for walking a call stack. Users who operate in one of
StackwalkerAPI’s standard configurations do not need to use the Callback
Interface.

Figure `[fig:object-ownership] <#fig:object-ownership>`__ shows the
ownership hierarchy for StackwalkerAPI’s classes. Ownership is a
"contains" relationship; if one class owns another, then instances of
the owner class maintain an exclusive instance of the other. For
example, in Figure `[fig:object-ownership] <#fig:object-ownership>`__
the each Walker instance contains exactly one instance of a ProcessState
object. No other instance of Walker uses that instance of ProcessState.

This remainder of this section briefly describes the six classes that
make up StackwalkerAPI’s two interfaces. For more details, see the class
descriptions in Section `3 <#sec:api>`__.

= [rectangle, draw, rounded corners]

Stackwalking Interface
----------------------

Walker
   The Walker class is the top-level class used for collecting
   stackwalks. It provides a simple interface for requesting a
   stackwalk. Each Walker object is associated with one process, but may
   walk the call stacks of multiple threads within that process.

Frame
   A call stack is returned as a vector of Frame objects, where each
   Frame object represents a stack frame. It can provide information
   about the stack frame and basic information about the function,
   signal handler or other mechanism that created it. Users can request
   information such as the symbolic name associated with the Frame
   object, and values of its saved registers.

Stackwalk Callback Interface
----------------------------

StackwalkerAPI includes default implementations of the Callback
Interface on each of its supported platforms. These default
implementations allow StackwalkerAPI to work "out of the box" in a
standard configuration on each platform. Users can port StackwalkerAPI
to new platforms or customize its call stack walking behavior by
implementing their own versions of the classes in the Callback
Interface.

FrameStepper
   A FrameStepper object describes how to walk through a single type of
   stack frame. Users can provide an implementation of this interface
   that allows StackwalkerAPI to walk through new types of stack frames.
   For example, the DyninstAPI uses this interface to extend
   StackwalkerAPI to allow it to walk through stack frames created by
   instrumentation code.

StepperGroup
   A StepperGroup is a collection of FrameStepper objects and criteria
   that describes when to use each type of FrameStepper. These criteria
   are based on simple address ranges in the code space of the target
   process. In the above example with DyninstAPI, it would be the job of
   the StepperGroup to identify a stack frame as belonging to
   instrumentation code and use the instrumentation FrameStepper to walk
   through it.

ProcessState
   A ProcessState interface describes how to access data in the target
   process. To walk a call stack, StackwalkerAPI needs to access both
   registers and memory in the target process; ProcessState provides an
   interface that StackwalkerAPI can use to access that information.
   StackwalkerAPI includes two default implementation of ProcessState
   for each platform: one to collect a first party stackwalk in the
   current process, and one that uses a debugger interface to collect a
   third party stackwalk in another process.

SymbolLookup
   The SymbolLookup interface is used to associate a symbolic name with
   a stack frame. A stackwalk returns a collection of addresses in the
   code space of a binary. This class uses the binary’s symbol table to
   map those addresses into symbolic names. A default implementation of
   this class, which uses the DynSymtab package, is provided with
   StackwalkerAPI. A user could, for example, use this interface to
   allow StackwalkerAPI to use libelf to look up symbol names instead.



Callback Interface Default Implementations
==========================================

StackwalkerAPI provides one or more default implementations of each of
the callback classes described in Section 3.5. These implementations are
used by a default configuration of StackwalkerAPI.

.. _`subsec:debugger`:

Debugger Interface
------------------

This section describes how to use StackwalkerAPI for collecting 3rd
party stack walks. In 3rd party mode StackwalkerAPI uses the OS’s
debugger interface to connect to another process and walk its call
stacks. As part of being a debugger StackwalkerAPI receives and needs to
handle debug events. When a debugger event occurs, StackwalkerAPI must
get control of the host process in order to receive the debugger event
and continue the target process.

To illustrate the complexities with running in 3rd party mode, consider
the follow code snippet that uses StackwalkerAPI to collect a stack walk
every five seconds.

.. code-block:: cpp
    
   Walker *walker = Walker::newWalker(pid);
   std::vector<Frame> swalk;
   for (;;) {
   		walker->walkStack(swalk);
   		sleep(5);
   }

StackwalkerAPI is running in 3rd party mode, since it attached to the
target process, ``pid``. As the target process runs it may be generating
debug events such a thread creation and destruction, library loads and
unloads, signals, forking/execing, etc. When one of these debugger
events is generated the OS will pause the target process and send a
notice to the host process. The target process will remain paused until
the host process handles the debug event and resumes the target process.

In the above example the host process is spending almost all of its time
in the sleep call. If a debugger event happens during the sleep, then
StackwalkerAPI will not be able to get control of the host process and
handle the event for up to five seconds. This will cause long pauses in
the target process and lead to a potentially very large slowdown.

To work around this problem StackwalkerAPI provides a notification file
descriptor. This file descriptor represents a connection between the
StackwalkerAPI library and user code. StackwalkerAPI will write a single
byte to this file descriptor when a debug event occurs, thus notifying
the user code that it needs to let StackwalkerAPI receive and handle
debug events. The user code can use system calls such as select to watch
for events on the notification file descriptor.

The following example illustrates how to properly use StackwalkerAPI to
collect a stack walk from another process at a five second interval.
Details on the ``ProcDebug`` class, ``getNotificationFD`` method, and
``handleDebugEvent`` method can be found in
Section `4.1.1 <#subsubsec:procdebug>`__. See the UNIX man pages for
more information on the ``select`` system call. Note that this example
does not include all of the proper error handling and includes that
should be present when using ``select``.

.. code-block:: cpp

   Walker *walker = Walker::newWalker(pid);
   ProcDebug *debugger = (ProcDebug *) walker->getProcessState();
   std::vector<Frame> swalk;
   for (;;) {
       walker->walkStack(swalk);		
       struct timeval timeout;
       timeout.tv_sec = 5;
       timeout.tv_usec = 0;
       int max = 1;
       fd_set readfds, writefds, exceptfds;
       FD_ZERO(&readfds); FD_ZERO(&writefds); FD_ZERO(&exceptfds);
       FD_SET(ProcDebug::getNotificationFD(), &readfds);
       for (;;) {
           int result = select(max, &readfds, &writefds, &exceptfds, &timeout);
           if (FD_ISSET(ProcDebug::getNotificationFD(), readfds)) {
               //Debug event
               ProcDebug::handleDebugEvent();
           }
           if (result == 0) {
               //Timeout
               break;
           }
       }
   }

.. _`subsubsec:procdebug`:

Class ProcDebug
~~~~~~~~~~~~~~~

**Defined in:** ``procstate.h``

Access to StackwalkerAPI’s debugger is through the ``ProcDebug`` class,
which inherits from the ``ProcessState`` interface. The easiest way to
get at a ``ProcDebug`` object is to cast the return value of
``Walker::getProcessState`` into a ``ProcDebug``. C++’s ``dynamic_cast``
operation can be used to test if a ``Walker`` uses the ``ProcDebug``
interface:

.. code-block:: cpp

   ProcDebug *debugger;
   debugger = dynamic_cast<ProcDebug*>(walker->getProcessState());
   if (debugger != NULL) {
       //3rd party
       ...
   } else {
       //1st party
       ...
   }

In addition to the handling of debug events, described in
Section `4.1 <#subsec:debugger>`__, the ``ProcDebug`` class provides a
process control interface; users can pause and resume process or
threads, detach from a process, and test for events such as process
death. As an implementation of the ``ProcessState`` class, ``ProcDebug``
also provides all of the functionality described in
Section `3.6.4 <#subsec:processstate>`__.

.. code-block:: cpp

    virtual bool pause(Dyninst::THR_ID tid = NULL_THR_ID)

This method pauses a process or thread. The paused object will not
resume execution until ``ProcDebug::resume`` is called. If the ``tid``
parameter is not ``NULL_THR_ID`` then StackwalkerAPI will pause the
thread specified by ``tid``. If ``tid`` is ``NULL_THR_ID`` then
StackwalkerAPI will pause every thread in the process.

When StackwalkerAPI collects a call stack from a running thread it first
pauses the thread, collects the stack walk, and then resumes the thread.
When collecting a call stack from a paused thread StackwalkerAPI will
collect the stack walk and leave the thread paused. This method is thus
useful for pausing threads before stack walks if the user needs to keep
the returned stack walk synchronized with the current state of the
thread.

This method returns ``true`` if successful and ``false`` on error.

.. code-block:: cpp

    virtual bool resume(Dyninst::THR_ID tid = NULL_THR_ID)

This method resumes execution on a paused process or thread. This method
only resumes threads that were paused by the ``ProcDebug::pause`` call,
using it on other threads is an error. If the ``tid`` parameter is not
``NULL_THR_ID`` then StackwalkerAPI will resume the thread specified by
``tid``. If ``tid`` is ``NULL_THR_ID`` then StackwalkerAPI will resume
all paused threads in the process.

This method returns ``true`` if successful and ``false`` on error.

.. code-block:: cpp

    virtual bool detach(bool leave_stopped = false)

This method detaches StackwalkerAPI from the target process.
StackwalkerAPI will no longer receive debug events on this target
process and will no longer be able to collect call stacks from it. This
method invalidates the associated ``Walker`` and ``ProcState`` objects,
they should be cleaned using C++’s ``delete`` operator after making this
call. It is an error to attempt to do operations on these objects after
a detach, and undefined behavior may result.

If the ``leave_stopped`` parameter is ``true`` StackwalkerAPI will
detach from the process but leave it in a paused state so that it does
resume progress. This is useful for attaching another debugger back to
the process for further analysis. The ``leave_stopped`` parameter is not
supported on the Linux platform and its value will have no affect on the
detach call.

This method returns ``true`` if successful and ``false`` on error.

.. code-block:: cpp

    virtual bool isTerminated()

This method returns ``true`` if the associated target process has
terminated and ``false`` otherwise. A target process may terminate
itself by calling exit, returning from main, or receiving an unhandled
signal. Attempting to collect stack walks or perform other operations on
a terminated process is illegal an will lead to undefined behavior.

A process termination will also be signaled through the notification FD.
Users should check processes for the isTerminated state after returning
from handleDebugEvent.

.. code-block:: cpp

    static int getNotificationFD()

This method returns StackwalkerAPI’s notification FD. The notification
FD is a file descriptor that StackwalkerAPI will write a byte to
whenever a debug event occurs that need. If the user code sees a byte on
this file descriptor it should call ``handleDebugEvent`` to let
StackwalkerAPI handle the debug event. Example code using
``getNotificationFD`` can be found in
Section `4.1 <#subsec:debugger>`__.

StackwalkerAPI will only create one notification FD, even if it is
attached to multiple 3rd party target processes.

.. code-block:: cpp

    static bool handleDebugEvent(bool block = false)

When this method is called StackwalkerAPI will receive and handle all
pending debug events from each 3rd party target process to which it is
attached. After handling debug events each target process will be
continued (unless it was explicitly stopped by the ProcDebug::pause
method) and any bytes on the notification FD will be cleared. It is
generally expected that users will call this method when a event is sent
to the notification FD, although it can be legally called at any time.

If the ``block`` parameter is ``true``, then ``handleDebugEvents`` will
block until it has handled at least one debug event. If the block
parameter is ``false``, then handleDebugEvents will handle any currently
pending debug events or immediately return if none are available.

StackwalkerAPI may receive process exit events for target processes
while handling debug events. The user should check for any exited
processes by calling ``ProcDebug::isTerminated`` after handling debug
events.

This method returns ``true`` if successful and ``false`` on error.

.. _`sec:framesteppers`:

FrameSteppers
-------------

**Defined in:** ``framestepper.h``

StackwalkerAPI ships with numerous default implementations of the
``FrameStepper`` class. Each of these ``FrameStepper`` implementations
allow StackwalkerAPI to walk a type of call frames.
Section `3.6.1 <#subsec:defaults>`__ describes which ``FrameStepper``
implementations are available on which platforms. This sections gives a
brief description of what each ``FrameStepper`` implementation does.
Each of the following classes implements the ``FrameStepper`` interface
described in Section `3.6.2 <#subsec:framestepper>`__, so we do not
repeat the API description for the classes here.

Several of the ``FrameStepper``\ s use helper classes (see
``FrameFuncStepper`` as an example). Users can further customize the
behavior of a ``FrameStepper`` by providing their own implementation of
these helper classes.

Class FrameFuncStepper
~~~~~~~~~~~~~~~~~~~~~~

This class implements stack walking through a call frame that is setup
with the architectures standard stack frame. For example, on x86 this
``FrameStepper`` will be used to walk through stack frames that are
setup with a ``push %ebp/mov %esp,%ebp`` prologue.

Class FrameFuncHelper
~~~~~~~~~~~~~~~~~~~~~

``FrameFuncStepper`` uses a helper class, ``FrameFuncHelper``, to get
information on what kind of stack frame it’s walking through. The
``FrameFuncHelper`` will generally use techniques such as binary
analysis to determine what type of stack frame the ``FrameFuncStepper``
is walking through. Users can have StackwalkerAPI use their own binary
analysis mechanisms by providing an implementation of this
``FrameFuncHelper``.

There are two important types used by ``FrameFuncHelper`` and one
important function: typedef enum unknown_t=0, no_frame, standard_frame,
savefp_only_frame, frame_type;

The ``frame_type`` describes what kind of stack frame a function uses.
If it does not set up a stack frame then ``frame_type`` should be
``no_frame``. If it sets up a standard frame then ``frame_type`` should
be ``standard_frame``. The ``savefp_only_frame`` value currently only
has meaning on the x86 family of systems, and means that a function
saves the old frame pointer, but does not setup a new frame pointer (it
has a ``push %ebp`` instruction, but no ``mov %esp,%ebp``). If the
``FrameFuncHelper`` cannot determine the ``frame_type``, then it should
be assigned the value ``unknown_t``.

.. code-block:: cpp

    typedef enum unknown_s=0, unset_frame, halfset_frame, set_frame frame_state;

The ``frame_state`` type determines the current state of function with a
stack frame at some point of execution. For example, a function may set
up a standard stack frame and have a ``frame_type`` of
``standard_frame``, but execution may be at the first instruction in the
function and the frame is not yet setup, in which case the
``frame_state`` will be ``unset_frame``.

If the function sets up a standard stack frame and the execution point
is someplace where the frame is completely setup, then the
``frame_state`` should be ``set_frame``. If the function sets up a
standard frame and the execution point is at a point where the frame
does not yet exist or has been torn down, then ``frame_state`` should be
``unset_frame``. The ``halfset_frame`` value of ``frame_state`` is
currently only meaningful on the x86 family of architecture, and should
if the function has saved the old frame pointer, but not yet set up a
new frame pointer.

.. code-block:: cpp

    typedef std::pair<frame_type, frame_state> alloc_frame_t; virtual alloc_frame_t allocatesFrame(Address addr) = 0;

The ``allocatesFrame`` function of ``FrameFuncHelper`` returns a
``alloc_frame_t`` that describes the frame_type of the function at
``addr`` and the ``frame_state`` of the function when execution reached
``addr``.

If ``addr`` is invalid or an error occurs, allocatedFrame should return
``alloc_frame_t(unknown_t, unknown_s)``.

Class SigHandlerStepper
~~~~~~~~~~~~~~~~~~~~~~~

The ``SigHandlerStepper`` is used to walk through UNIX signal handlers
as found on the call stack. On some systems a signal handler generates a
special kind of stack frame that cannot be walked through using normal
stack walking techniques.

Class DebugStepper
~~~~~~~~~~~~~~~~~~

This class uses debug information found in a binary to walk through a
stack frame. It depends on SymtabAPI to read debug information from a
binary, then uses that debug information to walk through a call frame.

Most binaries must be built with debug information (``-g`` with ``gcc``)
in order to include debug information that this ``FrameStepper`` uses.
Some languages, such as C++, automatically include stackwalking debug
information for use by exceptions. The ``DebugStepper`` class will also
make use of this kind of exception information if it is available.

Class AnalysisStepper
~~~~~~~~~~~~~~~~~~~~~

This class uses dataflow analysis to determine possible stack sizes at
all locations in a function as well as the location of the frame
pointer. It is able to handle optimized code with omitted frame pointers
and overlapping code sequences.

Class StepperWanderer
~~~~~~~~~~~~~~~~~~~~~

This class uses a heuristic approach to find possible return addresses
in the stack frame. If a return address is found that matches a valid
caller of the current function, we conclude it is the actual return
address and construct a matching stack frame. Since this approach is
heuristic it can make mistakes leading to incorrect stack information.
It has primarily been replaced by the ``AnalysisStepper`` described
above.

Class BottomOfStackStepper
~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``BottomOfStackStepper`` doesn’t actually walk through any type of
call frame. Instead it attempts to detect whether the bottom of the call
stack has been reached. If so, ``BottomOfStackStepper`` will report
``gcf_stackbottom`` from its ``getCallerFrame`` method. Otherwise it
will report ``gcf_not_me``. ``BottomOfStackStepper`` runs with a higher
priority than any other ``FrameStepper`` class.
